/******************************************
有序向量的归并
1.申请一片空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2.设两个指针，指向位置分别为两个已经排序序列的起始位置
3.比较两个指针所指向的元素，选择相对小的元素放入合并空间
*******************************************/

template <typename T>
void Vector<T>::merge(lo, mi, hi)
{
	T* A = _elem + lo;//合并后的向量A[0,hi-lo)=elme[lo,hi)   [0......lo.........hi]0-lo处有序，归并排序lo至hi
	int lb = mi - lo;
	T* B = new[lb];//开辟新的空间，存放左半边
	for (Rank i = 0; i < mi; i++) B[i] = A[i];
	int lc = hi - mi;//后边的元素一定不会被覆盖，所以不用开辟新的空间
	T* C = _elem + mi;
	for (int i = 0, j = 0, k = 0; (j < lb) || (k < lc))//从中BC中取出更小者
	{
		if ((j < lb) && (lc <= k || B[j] < C[k])) A[i++] = B[j++];
		if ((k < lc) && (lb <= k || C[k] < B[j])) A[i++] = C[k++];
	}
	delete[]B;
}
